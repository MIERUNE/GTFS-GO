# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GTFSViewerDockWidget
                                 A QGIS plugin
 The plugin to show routes and stops from GTFS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-10-29
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Kanahiro Iguchi
        email                : kanahiro.iguchi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import tempfile
import urllib
import time
import zipfile
import shutil
import json

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import QThread, pyqtSignal
from qgis.core import QgsProject, QgsVectorLayer, QgsDataProvider

from .gtfs_jp_parser.__main__ import GTFS_JP

TEMPDIR = os.path.join(tempfile.gettempdir(), 'gtfsviewer')


class GTFSViewerLoader(QtWidgets.QDialog):

    geojsonWritingFinished = pyqtSignal(str)

    def __init__(self, zipfile: str, output_dir: str):
        """Constructor."""
        super().__init__()
        self.ui = uic.loadUi(os.path.join(os.path.dirname(
            __file__), 'gtfs_viewer_loader_base.ui'), self)

        self.zipfile = zipfile
        self.output_dir = output_dir

        self.downloader = None
        self.extractor = None

        shutil.rmtree(TEMPDIR)
        os.makedirs(TEMPDIR, exist_ok=True)

        self.start()

        self.ui.pushButton.clicked.connect(self.canceled)

    def start(self):
        if self.zipfile.startswith('http'):
            self.downloader = Downloader(self.zipfile)
            self.downloader.start()
            self.downloader.processFinished.connect(
                lambda: self.load_zip(self.downloader.download_path))
        else:
            self.load_zip(self.zipfile)

    def load_zip(self, zipfile_path):
        self.extractor = Extractor(zipfile_path)
        self.extractor.start()
        self.extractor.progressChanged.connect(self.ui.progressBar.setValue)
        self.extractor.processFinished.connect(
            lambda: self.finished(self.extractor.routes,
                                  self.extractor.stops,
                                  self.extractor.interpolated_stops))

    def finished(self, routes, stops, interpolated_stops):
        routes_geojson = {
            'type': 'FeatureCollection',
            'features': routes
        }
        stops_geojson = {
            'type': 'FeatureCollection',
            'features': stops
        }
        interpolated_stops = {
            'type': 'FeatureCollection',
            'features': interpolated_stops
        }
        with open(os.path.join(self.output_dir, 'routes.geojson'), mode='w') as f:
            json.dump(routes_geojson, f)
        with open(os.path.join(self.output_dir, 'stops.geojson'), mode='w') as f:
            json.dump(stops_geojson, f)
        with open(os.path.join(self.output_dir, 'interpolated_stops.geojson'), mode='w') as f:
            json.dump(stops_geojson, f)

        self.geojsonWritingFinished.emit(self.output_dir)
        self.close()

    def canceled(self):
        if self.downloader.isRunning():
            self.downloader.terminate()
            self.downloader = None

        if self.extractor.isRunning():
            self.extractor.terminate()
            self.extractor = None

        self.close()


class Downloader(QThread):
    processFinished = pyqtSignal()

    def __init__(self, zipfile_url: str, output_dir=None):
        super().__init__()
        self.zipfile_url = zipfile_url

        self.output_dir = output_dir
        if self.output_dir is None:
            self.output_dir = TEMPDIR

        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir, exist_ok=True)

        self.download_path = os.path.join(
            self.output_dir, f'{int(time.time())}.zip')

    def run(self):
        data = urllib.request.urlopen(self.zipfile_url).read()
        with open(self.download_path, mode='wb') as f:
            f.write(data)
        self.processFinished.emit()


class Extractor(QThread):
    progressChanged = pyqtSignal(int)
    processFinished = pyqtSignal()

    def __init__(self, zipfile_path: str):
        super().__init__()
        self.zipfile_path = zipfile_path
        self.routes = None
        self.stops = None
        self.interpolated_stops = None

    def run(self):
        extracted_path = os.path.join(TEMPDIR, 'extract')
        os.makedirs(extracted_path, exist_ok=True)
        with zipfile.ZipFile(self.zipfile_path) as z:
            z.extractall(extracted_path)
        gtfs_jp = GTFS_JP(extracted_path)
        self.routes = gtfs_jp.read_routes()
        self.stops = gtfs_jp.read_stops(no_diagrams=True)
        self.interpolated_stops = gtfs_jp.read_interpolated_stops()
        self.processFinished.emit()
