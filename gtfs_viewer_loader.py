# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GTFSViewerDockWidget
                                 A QGIS plugin
 The plugin to show routes and stops from GTFS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-10-29
        git sha              : $Format:%H$
        copyright            : (C) 2020 by MIERUNE Inc.
        email                : info@mierune.co.jp
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import tempfile
import urllib
import time
import zipfile
import shutil
import json

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import QThread, pyqtSignal

from .gtfs_jp_parser.__main__ import GTFS_JP
from .gtfs_viewer_settings import (
    FILENAME_ROUTES_GEOJSON,
    FILENAME_STOPS_GEOJSON
)

TEMPDIR = os.path.join(tempfile.gettempdir(), 'gtfsviewer')
MAX_PROGRESS_COUNT = 100


class GTFSViewerLoader(QtWidgets.QDialog):

    geojsonWritingFinished = pyqtSignal(str)

    def __init__(self, zipfile: str, output_dir: str, no_shapes=False, ignore_no_route_stops=False):
        """Constructor."""
        super().__init__()
        self.ui = uic.loadUi(os.path.join(os.path.dirname(
            __file__), 'gtfs_viewer_loader_base.ui'), self)

        self.zipfile = zipfile
        self.output_dir = output_dir
        self.no_shapes = no_shapes
        self.ignore_no_route_stops = ignore_no_route_stops

        # vars to store Classes working in other threads.
        self.downloader = None
        self.extractor = None

        self.ui.progressBar.setMaximum(MAX_PROGRESS_COUNT)

        shutil.rmtree(TEMPDIR)
        os.makedirs(TEMPDIR, exist_ok=True)

        self.start()

        self.ui.pushButton.clicked.connect(self.canceled)

    def start(self):
        if self.zipfile.startswith('http'):
            self.downloader = Downloader(self.zipfile)
            self.downloader.start()
            self.downloader.processFinished.connect(
                lambda: self.load_zip(self.downloader.download_path))
        else:
            self.load_zip(self.zipfile)

    def load_zip(self, zipfile_path):
        self.extractor = Extractor(zipfile_path,
                                   no_shapes=self.no_shapes,
                                   ignore_no_route_stops=self.ignore_no_route_stops)
        self.extractor.start()
        self.extractor.progressChanged.connect(self.ui.progressBar.setValue)
        self.extractor.processFinished.connect(
            lambda: self.finished(self.extractor.routes,
                                  self.extractor.stops))

    def finished(self, routes, stops):
        routes_geojson = {
            'type': 'FeatureCollection',
            'features': routes
        }
        stops_geojson = {
            'type': 'FeatureCollection',
            'features': stops
        }

        os.makedirs(self.output_dir, exist_ok=True)
        with open(os.path.join(self.output_dir, FILENAME_ROUTES_GEOJSON), mode='w') as f:
            json.dump(routes_geojson, f)
        with open(os.path.join(self.output_dir, FILENAME_STOPS_GEOJSON), mode='w') as f:
            json.dump(stops_geojson, f)

        self.geojsonWritingFinished.emit(self.output_dir)
        self.close()

    def canceled(self):
        if self.downloader is not None and self.downloader.isRunning():
            self.downloader.terminate()
            self.downloader = None

        if self.extractor is not None and self.extractor.isRunning():
            self.extractor.terminate()
            self.extractor = None

        self.close()


class Downloader(QThread):
    processFinished = pyqtSignal()

    def __init__(self, zipfile_url: str, output_dir=None):
        super().__init__()
        self.zipfile_url = zipfile_url

        self.output_dir = output_dir
        if self.output_dir is None:
            self.output_dir = TEMPDIR

        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir, exist_ok=True)

        self.download_path = os.path.join(
            self.output_dir, f'{int(time.time())}.zip')

    def run(self):
        data = urllib.request.urlopen(self.zipfile_url).read()
        with open(self.download_path, mode='wb') as f:
            f.write(data)
        self.processFinished.emit()


class Extractor(QThread):
    progressChanged = pyqtSignal(int)
    processFinished = pyqtSignal()

    def __init__(self, zipfile_path: str, no_shapes=False, ignore_no_route_stops=False):
        super().__init__()
        self.zipfile_path = zipfile_path
        self.no_shapes = no_shapes
        self.ignore_no_route_stops = ignore_no_route_stops
        self.routes = []
        self.stops = []

    def run(self):
        extracted_path = os.path.join(TEMPDIR, 'extract')
        os.makedirs(extracted_path, exist_ok=True)
        with zipfile.ZipFile(self.zipfile_path) as z:
            z.extractall(extracted_path)
        gtfs_jp = GTFS_JP(extracted_path)

        routes_count = gtfs_jp.routes_count()
        stops_count = gtfs_jp.stops_count()
        task_count_sum = routes_count + stops_count

        progress_counter = 0

        for route in gtfs_jp.read_routes(no_shapes=self.no_shapes):
            self.routes.append(route)
            progress_counter += 1
            self.progressChanged.emit(
                int(MAX_PROGRESS_COUNT * progress_counter // task_count_sum))

        for stop in gtfs_jp.read_stops(ignore_no_route=self.ignore_no_route_stops, no_diagrams=True):
            progress_counter += 1
            self.progressChanged.emit(
                int(MAX_PROGRESS_COUNT * progress_counter // task_count_sum))
            if stop:
                self.stops.append(stop)

        self.processFinished.emit()
